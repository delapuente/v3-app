{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","lib/sww-raw-cache.js","node_modules/sw-cache-helper/lib/cachehelper.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sww-raw-cache.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var RawCache = require('./lib/sww-raw-cache.js');\n\nself.RawCache = RawCache;\n","/* global Response, Request, Promise */\n'use strict';\n\nvar CacheHelper = require('sw-cache-helper');\n\nvar DEFAULT_MATCH_OPTIONS = {\n  ignoreSearch: false,\n  ignoreMethod: false,\n  ignoreVary: false\n};\n\n/**\n * Constructor for the RawCache object. It receives an object\n * with the configuration parameters.\n * @param {Object} options set of configuration parameters.\n */\nfunction RawCache(options) {\n  if (!options.cacheName) {\n    throw Error('This middleware needs a cache name.');\n  }\n\n  this.cacheName = options.cacheName;\n  this.matchOptions = {\n    ignoreSearch: options.ignoreSearch || DEFAULT_MATCH_OPTIONS.ignoreSearch,\n    ignoreMethod: options.ignoreMethod || DEFAULT_MATCH_OPTIONS.ignoreMethod,\n    ignoreVary: options.ignoreVary || DEFAULT_MATCH_OPTIONS.ignoreVary,\n  };\n  this.DEFAULT_CONTENT_TYPE = options.defaultContentType || 'text/html';\n}\n\n/**\n * Utility method to retrieve cache used by this middleware.\n * @returns {Promise} promise once resolved will contain the Cache object\n */\nRawCache.prototype._getCache = function getCache() {\n  return CacheHelper.getCache(this.cacheName);\n};\n\n// This middleware will support the following http methods\nRawCache.prototype.SUPPORTED_ACTIONS = ['get', 'post', 'put', 'delete'];\n\n/**\n * Handles the request and perform actions over the cache content\n * based on the http verb used for the request.\n * @param {Request} the request object.\n * @param {Response} the response object.\n */\nRawCache.prototype.onFetch = function onFetch(request, response) {\n  if (response) {\n    return Promise.resolve(response);\n  }\n\n  var method = request.method.toLowerCase();\n  if (this.SUPPORTED_ACTIONS.indexOf(method) === -1) {\n    // Method not supported, just bypass the request and do nothing\n    // in this layer\n    return null;\n  }\n\n  return this.preprocessRequest(request).then(function (request) {\n    return this[method].apply(this, [request, response]);\n  }.bind(this));\n};\n\n/**\n * Preprocess the request taking into account the matching options.\n * @param {Request} the request object.\n */\nRawCache.prototype.preprocessRequest = function (request) {\n  var clone = request.clone();\n  return clone.blob().then(function (body) {\n    if (['GET', 'HEAD'].indexOf(request.method) >= 0) {\n      body = undefined;\n    }\n    if (this.matchOptions.ignoreSearch) {\n      var url = new URL(request.url);\n      url.search = '';\n      request = new Request(url.href, {\n        method: request.method,\n        headers: request.headers,\n        body: body,\n        mode: request.mode,\n        credentials: request.credentials,\n        cache: request.cache\n      });\n    }\n    //TODO: Implement the rest of match options\n    return Promise.resolve(request);\n  }.bind(this));\n};\n\n/**\n * Get the content from this cache.\n * @param {Request} request the request object.\n * @param {Response} response the response object.\n * @returns {Promise} Promise with the response object cached or null\n */\nRawCache.prototype.get = function get(request) {\n  var _this = this;\n  return this._getCache().then(function(cache) {\n    return cache.match(request, _this.matchOptions);\n  });\n};\n\n/**\n * Removes the specified uri from the cache entry\n * @param {Request} request the request object.\n * @param {Response} response the response object.\n * @returns {Promise} Promise, result of removing from cache.\n */\nRawCache.prototype.delete = function del(request) {\n  var self = this;\n  return this._getCache().then(function(cache) {\n    return cache.delete(request).then(self._getOKResponse,\n       self._getErrorResponse);\n  });\n};\n\n/**\n * Removes the specified uri from the cache entry\n * @param {Request} request the request object.\n * @param {Response} response the response object.\n * @returns {Promise} Promise, 200 response if cached correctly.\n */\nRawCache.prototype.post = function post(request) {\n  var self = this;\n  return request.text().then(function(content) {\n    var contentType = request.headers.get('Content-Type') ||\n     self.DEFAULT_CONTENT_TYPE;\n    var response = new Response(content, {\n      'headers': {\n      \t'x-sww-raw-cache': self.cacheName + ';time=' + Date.now(),\n      \t'Content-Type': contentType\n      }\n    });\n    // We create a new request, with default GET method\n    var customRequest = new Request(request.url);\n    return self._getCache().then(function(cache) {\n      return cache.put(customRequest, response).then(self._getOKResponse,\n        self._getErrorResponse);\n    });\n  });\n};\n\n// In this version put and post work in the same way, this could change\n// in future versions.\nRawCache.prototype.put = RawCache.prototype.post;\n\n/**\n * Builds a 200 response to be returned when operations against the cache\n * are performed without problems.\n * @param (string) msg optional message\n * @returns (Response) response object\n */\nRawCache.prototype._getOKResponse = function(msg) {\n  var response = {\n    status: 'ok'\n  };\n  if (msg) {\n    response.msg = msg;\n  }\n\n  return new Response(response, {\n    'Content-Type': 'application/json'\n  });\n};\n\n/**\n * Builds a 500 response to be returned when operations against the cache\n * are performed with problems.\n * @param (string) msg optional message\n * @returns (Response) response object\n */\nRawCache.prototype._getErrorResponse = function(msg) {\n  var response = {\n    status: 'ko'\n  };\n  if (msg) {\n    response.msg = msg;\n  }\n\n  return new Response(response, {\n    'Content-Type': 'application/json',\n    'status': 500\n  });\n};\n\nmodule.exports = RawCache;\n","/* global caches, fetch, Promise, Request, module*/\n(function() {\n  'use strict';\n\n  var CacheHelper = {\n    defaultCacheName: 'offline',\n    getCache: function getCache(name) {\n      return caches.open(name);\n    },\n    getDefaultCache: function getDefaultCache() {\n      return this.getCache(this.defaultCacheName);\n    },\n    fetchAndCache: function fetchAndChache(request, cache) {\n      return fetch(request.clone()).then(function(response) {\n        var clone = response.clone();\n        if (parseInt(clone.status) < 400) {\n          cache.put(request.clone(), response.clone());\n        }\n\n        return response.clone();\n      });\n    },\n    addAll: function addAll(cache, urls) {\n      if (!cache) {\n        throw new Error('Need a cache to store things');\n      }\n      // Polyfill until chrome implements it\n      if (typeof cache.addAll !== 'undefined') {\n        return cache.addAll(urls);\n      }\n\n      var promises = [];\n      var self = this;\n      urls.forEach(function(url) {\n        promises.push(self.fetchAndCache(new Request(url), cache));\n      });\n\n      return Promise.all(promises);\n    }\n  };\n\n  module.exports = CacheHelper;\n})();\n"]}