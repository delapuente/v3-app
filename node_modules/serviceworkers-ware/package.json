{
  "name": "serviceworkers-ware",
  "version": "0.0.0",
  "description": "ServiceWorker framework to deal with common task managing request, allowing easy extensibility",
  "main": "dist/sww.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "http-server ."
  },
  "author": {
    "name": "Francisco Jordano",
    "email": "francisco@jordano.es"
  },
  "license": "MPL",
  "devDependencies": {
    "browserify": "^9.0.3",
    "chai": "^2.2.0",
    "gulp": "^3.8.11",
    "gulp-jshint": "^1.9.2",
    "gulp-sourcemaps": "^1.3.0",
    "gulp-watch": "^4.1.1",
    "gulp-webserver": "^0.9.0",
    "karma": "^0.12.31",
    "karma-chai": "^0.1.0",
    "karma-chrome-launcher": "^0.1.8",
    "karma-sinon": "^1.0.4",
    "karma-sw-mocha": "git://github.com/lodr/karma-sw-mocha.git#master",
    "mocha": "git://github.com/lodr/mocha.git#sw",
    "sinon": "^1.14.1",
    "vinyl-buffer": "^1.0.0",
    "karma-firefox-launcher": "^0.1.4",
    "vinyl-source-stream": "^1.0.0"
  },
  "dependencies": {
    "sw-cache-helper": "git+https://git@github.com/arcturus/sw-cache-helper.git"
  },
  "gitHead": "9d012736aca3dba946b73483bb5dd47a8101f25d",
  "readme": "# ServiceWorkerWare\n\n> An [Express](http://expressjs.com/)-like layer on top of `ServiceWorkers` to provide a way to easily plug functionality.\n\n**Compatibility**\n\nCurrently working in:\n- [Chrome Canary](https://www.google.co.uk/chrome/browser/canary.html)\n- [Mozilla Nightly](https://blog.wanderview.com/sw-builds/)\n\n## Philosophy\n\n`ServiceWorkers` are sold as the replacement for `AppCache`. But you can do more things than just cache network requests! They have a lifecycle and are able to listen to events (via postMessage), so you can write advanced caches, routers, and a lot more of things and have them run on the ServiceWorker.\n\nThis library follows the same pattern as the Express framework, allowing developers to write individual *middleware* pieces that can be layered in order to augment the default functionality.\n\n## Usage\n\nOur syntax is pretty similar to Express'. The first step is to load the basic library:\n\n```javascript\nimportScripts('../path/to/ServiceWorkerWare.js');\n```\n\nThen you can load as many additional layers as you might need. In this example we will just import one:\n\n```javascript\n // Defines a `myMiddleware` variable\nimportScripts('../myMiddleware.js');\n```\n\nOnce `myMiddleware` is loaded, you can `use` it with `ServiceWorkerWare` instances:\n\n```javascript\nvar worker = new self.ServiceWorkerWare();\nworker.use(myMiddleware);\n```\n\nAnd that will route the requests through `myMiddleware`.\n\nYou can also specify paths and HTTP verbs, so only requests that match the path or the verb will be handled by that middleware. For example:\n\n```javascript\nworker.post('/event/*', analyticsMiddleware);\n```\n\nMore than one middleware can be registered with one worker. You just need to keep in mind that the `request` and `response` objects will be passed to each middleware in the same order that they were registered.\n\n\n## Writing a middleware layer\n\nEach middleware instance is an object implementing one callback per `ServiceWorker` event type to be handled:\n\n```\n{\n    onInstall: fn1,\n    onActivate: fn2,\n    onFetch: fn3,\n    onMessage: fn4\n}\n```\n\nYou don't need to respond to all the events--you can opt to only implement a subset of methods you care about. For example, if you only want to handle requests, you just need to implement the `onFetch` method. But in that case you might be missing out on the full `ServiceWorker` potential: you can do things such as preloading and caching resources during installation, clear the caches during activation (if the worker has been updated) or even just control the worker's behaviour by sending it a message.\n\nAlso, in order to make it even more Express-like, you can write middleware in the following way if you just want to handle fetch events and don't care about the ServiceWorkers life cycle:\n\n```javascript\nvar worker = new self.ServiceWorkerWare();\nworker.get('/hello.html', function(request, response) {\n  return Promise.resolve(new Response('Hello world!), { headers: {'Content-Type': 'text/html'} });\n}\nworker.init();\n```\n\n## Events\n\n### `onInstall`\n\nIt will be called during ServiceWorker installation. This happens just once.\n\n### `onActivate`\n\nIt will be called just after `onInstall`, or each time that you update your ServiceWorker. It's useful to update caches or any part of your application logic.\n\n### `onFetch(request, response)` returns Promise\n\nWill be called whenever the browser requests a resource when the worker has been installed.\n\n* `request`: it's a standard [Request Object](https://fetch.spec.whatwg.org/#concept-request)\n* `response`: it's a standard [Response Object](https://fetch.spec.whatwg.org/#concept-response)\n\nYou need to `.clone()` the `request` before using it as some fields are one use only.\n\nAfter the whole process of iterating over the different middleware you need to return a `Response` object. Each middleware can use the previous `response` object to perform operations over the content, headers or anything.\n\nThe `request` object provides details that define which resource was requested. This callback might (or not) use those details when building the `Response` object that it must return.\n\nThe following example will handle URLs that start with `virtual/` with the simplest version of `onFetch`: a callback! None of the requested resources need to physically exist, they will be programmatically created by the handler on demand:\n\n```\nworker.get('virtual/.', function(request, response) {\n\n  var url = request.clone().url;\n\n  var content = '<html><body>'\n      + url + ' ' + Math.random()\n      + '<br/><a href=\"/demo/index.html\">index</a></body></html>';\n\n  return Promise.resolve(new Response(content, {\n    headers: {\n      'Content-Type': 'text/html',\n      'x-powered-by': 'ServiceWorkerWare'\n    }\n  }));\n});\n```\n\nThe output for any request that hits this URL will be the original address of the URL, and a randomly generated number. Note how we can even specify the headers for our response!\n\nRemember that the handler *must always return a Promise*.\n\n### `onMessage(?)`\n\nWe will receive this event if an actor (window, iframe, another worker or shared worker) performs a `postMessage` on the ServiceWorker to communicate with it.\n\n<!--\n\nNOTE: These two events are commented out until the discussions are clarified\n\n### `onBeforeEvicted(?)`\n\nThis is still under heavy discussion: it's a custom event that the User Agent sends to the worker to let it know that is going to be evicted.\n\n### `onEvicted(?)`\n\nAlso under heavy discussion.\n\n-->\n\n## Middleware examples\n\nThis package already incorporates two simple middlewares. They are available by default when you import it:\n\nTODO: I would suggest refactoring them away from this package\n\n### `StaticCacher`\n\nThis will let you preload and cache static content during the `ServiceWorker` installation.\n\nTODO: where does `self` come from? in which context is this being executed?\n\nFor example:\n\n```\nworker.use(new self.StaticCacher(['a.html', 'b.html' ...]));\n```\n\nUpon installation, this worker will load `a.html` and `b.html` and store their content in the default cache.\n\n### `SimpleOfflineCache`\n\nThis will serve contents stored in the default cache. If it cannot find a resource in the cache, it will perform a fetch and save it to the cache.\n\n### [<tt>ZipCacher</tt>](https://github.com/arcturus/zipcacher)\n\nThis is not built-in with this library. It enables you to specify a ZIP file to cache your resources from.\n\n```javascript\nimportScripts('./sww.js');\nimportScripts('./zipcacher.js');\n\nvar worker = new self.ServiceWorkerWare();\n\nworker.use(new ZipCacher('http://localhost:8000/demo/resources.zip'));\nworker.use(new self.SimpleOfflineCache());\nworker.init();\n```\n\n## Running the demo\n\nClone the repository, and then cd to the directory and run:\n\n```\nnpm install\ngulp webserver\n```\n\nTODO: use npm scripts to run gulp, avoid global gulp installation\n\nAnd go to `http://localhost:8000/demo/index.html` using any of the browsers where `ServiceWorker`s are supported.\n\nWhen you visit `index.html` the ServiceWorker will be installed and `/demo/a.html` will be preloaded and cached. In contrast, `/demo/b.html` will be cached only once it is visited (i.e. only once the user navigates to it).\n\nFor an example of more advanced programmatic functionality, you can also navigate to any URL of the form `http://localhost:8000/demo/virtual/<anything>` (where `anything` is any content you want to enter) and you'll receive an answer by the installed virtual URL handler middleware.\n\n# And what about testing?\nWe are working on an you can see the specs under `lib/spec` folder.\n\nPlease, launch:\n```bash\n$ gulp tests\n```\n\nOnce tests are complete, [Karma](http://karma-runner.github.io/0.12/index.html), the testing framework, keeps monitoring your files to relaunch the tests when something is modified. Do not try to close the browsers. If you want to stop testing, kill the Karma process.\n\nThis should be straightforward for Windows and iOS. As usual, if your are on Linux or you're having problems with binary routes, try setting some environment variables:\n```bash\n$ FIREFOX_NIGHTLY_BIN=/path/to/nightly-bin CHROME_CANARY_BIN=/path/to/canary-bin gulp tests\n```\n\n## Thanks!\n\nA lot of this code has been inspired by different projects:\n\n- [Firefox OS V3 Architecture] (https://github.com/fxos/contacts)\n- [Shed] (https://github.com/wibblymat/shed)\n- [sw-precache](https://github.com/jeffposnick/sw-precache)\n- [offliner](https://github.com/lodr/offliner)\n\n## License\n\nMozilla Public License 2.0\n\nhttp://mozilla.org/MPL/2.0/\n\n",
  "readmeFilename": "README.md",
  "_id": "serviceworkers-ware@0.0.0",
  "_shasum": "d526ccf773b26d2013f882e34c4ede275c97e1b1",
  "_from": "git://github.com/arcturus/serviceworkerware.git",
  "_resolved": "git://github.com/arcturus/serviceworkerware.git#9d012736aca3dba946b73483bb5dd47a8101f25d",
  "_fromGithub": true
}
